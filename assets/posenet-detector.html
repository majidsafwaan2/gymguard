<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PoseNet Detection</title>
</head>
<body>
  <video id="video" autoplay playsinline style="width: 100%; height: 100%; position: absolute; top: 0; left: 0;"></video>
  <canvas id="canvas" style="width: 100%; height: 100%; position: absolute; top: 0; left: 0;"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <script>
    let detector = null;
    let videoElement = null;
    let canvasElement = null;
    let canvasCtx = null;
    let stream = null;

    async function initPoseNet() {
      try {
        console.log('Initializing PoseNet...');
        
        // Create MoveNet detector
        const model = poseDetection.SupportedModels.MoveNet;
        detector = await poseDetection.createDetector(model, {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER,
          enableSmoothing: true,
        });

        console.log('PoseNet initialized successfully');
        
        // Start camera
        startCamera();
      } catch (error) {
        console.error('Failed to initialize PoseNet:', error);
      }
    }

    function startCamera() {
      videoElement = document.getElementById('video');
      canvasElement = document.getElementById('canvas');
      canvasCtx = canvasElement.getContext('2d');

      navigator.mediaDevices.getUserMedia({ 
        video: { 
          facingMode: 'user',
          width: { ideal: 640 },
          height: { ideal: 480 }
        } 
      })
      .then(mediaStream => {
        stream = mediaStream;
        videoElement.srcObject = stream;
        videoElement.onloadedmetadata = () => {
          canvasElement.width = videoElement.videoWidth;
          canvasElement.height = videoElement.videoHeight;
          detectPoses();
        };
      })
      .catch(err => console.error('Camera error:', err));
    }

    async function detectPoses() {
      if (!detector || !videoElement) return;

      const poses = await detector.estimatePoses(videoElement);
      
      // Clear canvas
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      
      // Draw keypoints and skeleton
      if (poses && poses.length > 0) {
        const pose = poses[0];
        drawPose(pose);
      }

      requestAnimationFrame(detectPoses);
    }

    function drawPose(pose) {
      const keypoints = pose.keypoints;
      
      // Draw connections first
      drawConnections(keypoints);
      
      // Draw keypoints
      keypoints.forEach(keypoint => {
        if (keypoint.score > 0.3) {
          canvasCtx.fillStyle = '#00ff00';
          canvasCtx.fillRect(keypoint.x - 4, keypoint.y - 4, 8, 8);
        }
      });
    }

    function drawConnections(keypoints) {
      const connections = [
        [keypoints[9], keypoints[7]],  // Left eye - right eye
        [keypoints[7], keypoints[5]],  // Right eye - right ear
        [keypoints[9], keypoints[5]], // Left eye - left ear
        [keypoints[11], keypoints[12]], // Left shoulder - right shoulder
        [keypoints[11], keypoints[13]], // Left shoulder - left elbow
        [keypoints[12], keypoints[14]], // Right shoulder - right elbow
        [keypoints[13], keypoints[15]], // Left elbow - left wrist
        [keypoints[14], keypoints[16]], // Right elbow - right wrist
        [keypoints[11], keypoints[23]], // Left shoulder - left hip
        [keypoints[12], keypoints[24]], // Right shoulder - right hip
        [keypoints[23], keypoints[24]], // Left hip - right hip
        [keypoints[23], keypoints[25]], // Left hip - left knee
        [keypoints[24], keypoints[26]], // Right hip - right knee
        [keypoints[25], keypoints[27]], // Left knee - left ankle
        [keypoints[26], keypoints[28]], // Right knee - right ankle
      ];

      connections.forEach(([start, end]) => {
        if (start && end && start.score > 0.3 && end.score > 0.3) {
          canvasCtx.strokeStyle = '#00ffff';
          canvasCtx.lineWidth = 2;
          canvasCtx.beginPath();
          canvasCtx.moveTo(start.x, start.y);
          canvasCtx.lineTo(end.x, end.y);
          canvasCtx.stroke();
        }
      });
    }

    // Initialize when page loads
    window.addEventListener('load', initPoseNet);

    // Cleanup when page unloads
    window.addEventListener('beforeunload', () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>
